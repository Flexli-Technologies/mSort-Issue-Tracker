name: Unassign and Reassign All Issues

on:
  workflow_dispatch:
    inputs:
      max_issues:
        description: 'Maximum number of issues to process (0 = all)'
        required: false
        default: '0'

jobs:
  unassign-and-reassign:
    runs-on: ubuntu-latest
    permissions:
      issues: write
    
    steps:
      - name: Unassign and reassign issues
        uses: actions/github-script@v7
        with:
          script: |
            const maxIssues = parseInt('${{ github.event.inputs.max_issues }}') || 0;
            
            // Function to determine assignee
            function getAssignee(issue) {
              const issueBody = (issue.body || '').toLowerCase();
              const issueTitle = (issue.title || '').toLowerCase();
              const labels = issue.labels.map(label => label.name.toLowerCase());
              
              let assignee = null;
              
              // Check labels first (priority)
              if (labels.includes('category:electronics')) {
                assignee = 'mayoogh-flexli';
              } else if (labels.includes('category:mechanical')) {
                assignee = 'TusharRflexli';
              } else if (labels.includes('category:embedded')) {
                assignee = 'FlexliTushar';
              } else if (labels.includes('category:software')) {
                assignee = 'FlexliTushar';
              }
              
              // If no label match, check keywords in title and body
              if (!assignee) {
                const content = issueTitle + ' ' + issueBody;
                
                if (content.includes('firmware') || content.includes('code') || content.includes('program')) {
                  assignee = 'FlexliTushar';
                } else if (content.includes('mechanical')) {
                  assignee = 'TusharRflexli';
                } else if (content.includes('harness') || content.includes('pcb')) {
                  assignee = 'mayoogh-flexli';
                }
              }
              
              return assignee;
            }
            
            // Get all open issues
            let allIssues = [];
            let page = 1;
            const perPage = 100;
            
            console.log('Fetching all open issues...');
            
            while (true) {
              const issues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: perPage,
                page: page
              });
              
              if (issues.data.length === 0) break;
              
              // Filter out pull requests
              const onlyIssues = issues.data.filter(issue => !issue.pull_request);
              allIssues = allIssues.concat(onlyIssues);
              
              if (issues.data.length < perPage) break;
              page++;
              
              // Limit if maxIssues is set
              if (maxIssues > 0 && allIssues.length >= maxIssues) {
                allIssues = allIssues.slice(0, maxIssues);
                break;
              }
            }
            
            console.log(`Found ${allIssues.length} open issues to process\n`);
            
            let unassigned = 0;
            let reassigned = 0;
            let noMatch = 0;
            let failed = 0;
            
            // STEP 1: Unassign all issues that have assignees
            console.log('=== STEP 1: Unassigning all issues ===');
            for (const issue of allIssues) {
              if (issue.assignees && issue.assignees.length > 0) {
                try {
                  const assigneeLogins = issue.assignees.map(a => a.login);
                  await github.rest.issues.removeAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    assignees: assigneeLogins
                  });
                  console.log(`✓ Unassigned issue #${issue.number} from: ${assigneeLogins.join(', ')}`);
                  unassigned++;
                  
                  // Add a small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                  console.error(`✗ Failed to unassign issue #${issue.number}: ${error.message}`);
                  failed++;
                }
              }
            }
            
            console.log(`\nUnassigned ${unassigned} issues\n`);
            
            // STEP 2: Reassign based on labels and keywords
            console.log('=== STEP 2: Reassigning based on labels and keywords ===');
            for (const issue of allIssues) {
              const assignee = getAssignee(issue);
              
              if (assignee) {
                try {
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    assignees: [assignee]
                  });
                  console.log(`✓ Assigned issue #${issue.number} to ${assignee}`);
                  reassigned++;
                  
                  // Add a small delay to avoid rate limiting
                  await new Promise(resolve => setTimeout(resolve, 100));
                } catch (error) {
                  console.error(`✗ Failed to assign issue #${issue.number}: ${error.message}`);
                  failed++;
                }
              } else {
                console.log(`○ No matching criteria for issue #${issue.number}`);
                noMatch++;
              }
            }
            
            // Summary
            console.log('\n=== Summary ===');
            console.log(`Total issues processed: ${allIssues.length}`);
            console.log(`Unassigned: ${unassigned}`);
            console.log(`Reassigned: ${reassigned}`);
            console.log(`No match found: ${noMatch}`);
            console.log(`Failed operations: ${failed}`);
            
            // Create a comment on the workflow run with summary
            core.summary
              .addHeading('Unassign and Reassign Summary')
              .addTable([
                [{data: 'Metric', header: true}, {data: 'Count', header: true}],
                ['Total Issues Processed', allIssues.length.toString()],
                ['Unassigned', unassigned.toString()],
                ['Successfully Reassigned', reassigned.toString()],
                ['No Match Found', noMatch.toString()],
                ['Failed Operations', failed.toString()]
              ])
              .write();
